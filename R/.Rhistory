#rm(list = ls())
source("D:/Users/Applications/Tools/sourcedir.R")
path <- "D:/Users/Applications/Tools/Nirs/Package/Pack_nirs/R"
sourcedir(path, FALSE)
path <- "D:/Users/Applications/Tools/Nirs/Package/Fun_annex"
sourcedir(path, FALSE)
library(colorspace)
library(data.table)
library(ggplot2)
library(grDevices)
library(FNN)
library(MASS)
library(pls)
library(Rfast)
library(scales)
library(signal)
#library(nirs)
library(gridExtra)
library(tdisplay)
library(microbenchmark)
set.seed(seed = 2)
n <- 8
p <- 6
X <- matrix(rnorm(n * p, mean = 10), ncol = p, byrow = TRUE)
y <- 100 * rnorm(nrow(X))
set.seed(seed = NULL)
X
qr(X)$rank
colMeans(X)
xmeans <- colMeans(X)
ymean <- mean(y)
zX <- scale(X, center = xmeans, scale = FALSE)
zy <- y - ymean
ncomp <- 3
fm <- plsr(y ~ X, ncomp = ncomp, method = "kernel")
z <- plsfit.kernel(X, y, ncomp = ncomp)
fm$scores
z$Tr
fm$loadings
z$P
fm$projection
z$R
z$W %*% solve(crossprod(z$P, z$W))
z$Tr
zX %*% z$R
i <- 2
u <- z$Tr[, i] ; sum(u * u)
u <- z$W[, i] ; sum(u * u)
u <- z$P[, i] ; sum(u * u)
u <- z$R[, i] ; sum(u * u)
# b
# for y centered
fm$Yloading
z$b
coef(lm(zy ~ z$Tr - 1))
# for y
c(z$ymean, z$b)
coef(lm(y ~ z$Tr))
# beta (= for X) coefficients
# for y centered
a <- 2
beta <- z$R[, 1:a, drop = FALSE] %*% z$b[1:a]
beta
coef(plsr(y ~ X, ncomp = a))
# for y
beta0 <- z$ymean - sum(z$xmean * beta)
c(beta0, beta)
coef(plsr(y ~ X, ncomp = a), intercept = TRUE)
# Predictions
i <- 2
xu <- X[i, , drop = FALSE]
pls(X, y, xu, ncomp = ncomp)$Tu
tu <- zpls.kernel(X, y, xu, ncomp = ncomp)$Tu
tu
(xu - z$xmeans) %*%  z$R
plsreg(X, y, xu, ncomp = ncomp)$pred
a <- 1
#a <- 2
#a <- 3
ymean + tu[, 1:a] %*% z$b[1:a]
beta <- z$R[, 1:a, drop = FALSE] %*% z$b[1:a]
ymean - z$xmeans %*%  beta + xu %*% beta
ymean + (xu - z$xmeans) %*%  beta
#######------------- PLS2
n <- 8
p <- 6
X <- matrix(rnorm(n * p, mean = 10), ncol = p, byrow = TRUE)
y1 <- 100 * rnorm(nrow(X))
y2 <- 100 * rnorm(nrow(X))
y <- cbind(y1, y2)
xmeans <- colMeans(X)
ymeans <- colMeans(y)
zX <- scale(X, center = xmeans, scale = FALSE)
zy <- scale(y, center = ymeans, scale = FALSE)
ncomp <- 3
fm <- plsr(y ~ X, ncomp = ncomp, method = "kernel")
z <- plsfit.kernel(X, y, ncomp = ncomp)
fm$scores
z$Tr
fm$loadings
z$P
fm$projection
z$R
z$W %*% solve(crossprod(z$P, z$W))
z$Tr
zX %*% z$R
fm$Yloadings
z$b
# Predictions
i <- 2
xu <- X[i, , drop = FALSE]
pls(X, y, xu, ncomp = ncomp)$Tu
tu <- plsfit.kernel(X, y, xu, ncomp = ncomp)$Tu
tu
(xu - z$xmeans) %*%  z$R
plsreg(X, y, xu, ncomp = ncomp)$pred
a <- 1
#a <- 2
#a <- 3
ymean + tu[, 1:a] %*% z$b[1:a]
beta <- z$R[, 1:a, drop = FALSE] %*% z$b[1:a]
ymean - z$xmeans %*%  beta + xu %*% beta
ymean + (xu - z$xmeans) %*%  beta
#######------------- PLS2
n <- 8
p <- 6
X <- matrix(rnorm(n * p, mean = 10), ncol = p, byrow = TRUE)
y1 <- 100 * rnorm(nrow(X))
y2 <- 100 * rnorm(nrow(X))
y <- cbind(y1, y2)
xmeans <- colMeans(X)
ymeans <- colMeans(y)
zX <- scale(X, center = xmeans, scale = FALSE)
zy <- scale(y, center = ymeans, scale = FALSE)
ncomp <- 3
fm <- plsr(y ~ X, ncomp = ncomp, method = "kernel")
z <- plsfit.kernel(X, y, ncomp = ncomp)
fm$scores
z$Tr
fm$loadings
z$P
fm$projection
z$R
z$W %*% solve(crossprod(z$P, z$W))
z$Tr
zX %*% z$R
fm$Yloadings
z$b
pca
pcasvd
sxale(1:10)
scale(1:10)
svd
?svd
source('D:/Users/Applications/Tools/Nirs/Package/Pack_nirs/R/plsfit.kernel.R')
source('D:/Users/Applications/Tools/Nirs/Package/Pack_nirs/R/plsfit.kernel.R')
